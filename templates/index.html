<canvas id="gameWindow" width="600" height="900"></canvas>
<script>
const BOARD_OFFSET_X = 100;
const BOARD_OFFSET_Y = 100;
const FRAME_DELTA = 100; //ms
const CELL_SIZE = 40;
const NUM_CELLS_X = 10;
const NUM_CELLS_Y = 20;
const BOARD_WIDTH = CELL_SIZE*NUM_CELLS_X;
const BOARD_HEIGHT = CELL_SIZE*NUM_CELLS_Y;

const COLOR_ENUM = {
    BLACK: 0,
    CYAN: 1,
    YELLOW: 2,
    PURPLE: 3,
    GREEN: 4,
    BLUE: 5,
    RED: 6,
    ORANGE: 7
};

function color_to_string(enum_value)
{
    switch (enum_value) {
        case COLOR_ENUM.BLACK:
            return "black";
        case COLOR_ENUM.CYAN:
            return "cyan";
        case COLOR_ENUM.YELLOW:
            return "yellow";
        case COLOR_ENUM.PURPLE:
            return "purple";
        case COLOR_ENUM.GREEN:
            return "green";
        case COLOR_ENUM.BLUE:
            return "blue";
        case COLOR_ENUM.RED:
            return "red";
        case COLOR_ENUM.ORANGE:
            return "orange";
        default:
            throw new Error("Encountered an invalid color");
    }
}

class Piece {
    constructor(piece_type, piece_coords) {
        this.color = piece_type;
        this.origin = piece_coords;
        if (piece_type == 2) { // Square piece
            this.occupiedSquares = [
                this.origin,
                [this.origin[0]+1, this.origin[1]],
                [this.origin[0], this.origin[1]+1],
                [this.origin[0]+1, this.origin[1]+1]
            ];
        }
    };

    canFall(board) {
        let return_value = 1;
        this.occupiedSquares.forEach((occupiedSquare) => {
            if ((occupiedSquare[1] + 1 >= board.y_size) || board.board_rows[occupiedSquare[1] + 1][occupiedSquare[0]] != 0)
            {
                return_value = 0;
            }
        })
        return return_value;
    }

    fall(board) {
        // Check if we can fall
        if (this.canFall(board) == 1)
        {
            this.occupiedSquares.forEach((occupiedSquare) => {
                occupiedSquare[1] += 1;
            })
            return 0;
        }
        else
        {
            return 1;
        }
    }
    
    land(board) {
        this.occupiedSquares.forEach((occupiedSquare) => {
            board.board_rows[occupiedSquare[1]][occupiedSquare[0]] = this.color;
        })
    }
}

class Board {
    constructor(x_size, y_size) {
        this.x_size = x_size;
        this.y_size = y_size;
        this.board_rows = [];
        for (let i = 0; i < y_size; i++)
        {
            let board_row = [];
            for (let j = 0; j < x_size; j++)
            {
                board_row.push(0);
            }
            this.board_rows.push(board_row);
        }
    }
    
}



function drawGameboard(board) {
    var c = document.getElementById("gameWindow");
    var ctx = c.getContext("2d");
    ctx.clearRect(BOARD_OFFSET_X, BOARD_OFFSET_Y, BOARD_WIDTH, BOARD_HEIGHT);
    ctx.beginPath();
    ctx.rect(BOARD_OFFSET_X, BOARD_OFFSET_Y, BOARD_WIDTH, BOARD_HEIGHT);
    //filling cells
    for (let x = 0; x < board.x_size; x++)
    {
        for (let y = 0; y < board.y_size; y++)
        {
            ctx.fillStyle = color_to_string(board.board_rows[y][x]);
            ctx.fillRect(BOARD_OFFSET_X + x*CELL_SIZE + 1, BOARD_OFFSET_Y + y*CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
        }
    }
    ctx.stroke();
}

function drawPiece(piece) {
    var c = document.getElementById("gameWindow");
    var ctx = c.getContext("2d");
    piece.occupiedSquares.forEach((occupiedSquare) => {
        ctx.fillStyle = color_to_string(piece.color);
        ctx.fillRect(BOARD_OFFSET_X + occupiedSquare[0]*CELL_SIZE + 1, BOARD_OFFSET_Y + occupiedSquare[1]*CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
    });
}

function makePiece() {
    let piece = new Piece(2, [4, 0]);
    return piece;
}

let board = new Board(NUM_CELLS_X, NUM_CELLS_Y);
let ticks_to_fall = 3;
let fall_timer = ticks_to_fall;
piece = makePiece();

function gameLoop() {
    fall_timer--;
    if (fall_timer == 0) {
        if (piece.fall(board) == 1)
        {
            piece.land(board);
            piece = makePiece();
        }
        fall_timer = ticks_to_fall;
    }
    drawGameboard(board);
    drawPiece(piece);
}

setInterval(gameLoop, FRAME_DELTA);

</script>