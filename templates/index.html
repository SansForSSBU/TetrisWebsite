<head>
    <script src=https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js></script>
</head>
<canvas id="gameWindow" width="600" height="900"></canvas>
<script>
const BOARD_OFFSET_X = 100;
const BOARD_OFFSET_Y = 100;
const FRAME_DELTA = 100; //ms
const CELL_SIZE = 40;
const NUM_CELLS_X = 10;
const NUM_CELLS_Y = 20;
const BOARD_WIDTH = CELL_SIZE*NUM_CELLS_X;
const BOARD_HEIGHT = CELL_SIZE*NUM_CELLS_Y;

const COLOR_ENUM = {
    BLACK: 0,
    CYAN: 1,
    YELLOW: 2,
    PURPLE: 3,
    GREEN: 4,
    BLUE: 5,
    RED: 6,
    ORANGE: 7
};

function color_to_string(enum_value)
{
    switch (enum_value) {
        case COLOR_ENUM.BLACK:
            return "black";
        case COLOR_ENUM.CYAN:
            return "cyan";
        case COLOR_ENUM.YELLOW:
            return "yellow";
        case COLOR_ENUM.PURPLE:
            return "purple";
        case COLOR_ENUM.GREEN:
            return "green";
        case COLOR_ENUM.BLUE:
            return "blue";
        case COLOR_ENUM.RED:
            return "red";
        case COLOR_ENUM.ORANGE:
            return "orange";
        default:
            throw new Error("Encountered an invalid color");
    }
}

function randint(min, max) {
    return Math.floor(Math.random() * (max-min)) + min;
}

class Piece {
    constructor(pieceType) {
        this.color = pieceType;
        if (pieceType == 1) { // I piece
            this.origin = [4, 0];
            this.tiles = [
                this.origin,
                [this.origin[0], this.origin[1]+1],
                [this.origin[0], this.origin[1]+2],
                [this.origin[0], this.origin[1]+3]
            ]
        }
        if (pieceType == 2) { // O piece
            this.origin = [4, 0];
            this.tiles = [
                this.origin,
                [this.origin[0]+1, this.origin[1]],
                [this.origin[0], this.origin[1]+1],
                [this.origin[0]+1, this.origin[1]+1]
            ];
        }
        if (pieceType == 3) { // T piece
            this.origin = [4, 0];
            this.tiles = [
                this.origin,
                [this.origin[0]+1, this.origin[1]],
                [this.origin[0]+2, this.origin[1]],
                [this.origin[0]+1, this.origin[1]+1]
            ]
        }
        if (pieceType == 4) { // S piece
            this.origin = [4, 1];
            this.tiles = [
                this.origin,
                [this.origin[0]+1, this.origin[1]],
                [this.origin[0]+1, this.origin[1]-1],
                [this.origin[0]+2, this.origin[1]-1]
            ]
        }
        if (pieceType == 5) { // J piece
            this.origin = [4, 2];
            this.tiles = [
                this.origin,
                [this.origin[0]+1, this.origin[1]],
                [this.origin[0]+1, this.origin[1]-1],
                [this.origin[0]+1, this.origin[1]-2]
            ]
        }
        if (pieceType == 6) { // Z piece
            this.origin = [4, 0];
            this.tiles = [
                this.origin,
                [this.origin[0]+1, this.origin[1]],
                [this.origin[0]+1, this.origin[1]+1],
                [this.origin[0]+2, this.origin[1]+1]
            ]
        }
        if (pieceType == 7) { // L piece
            this.origin = [4, 0];
            this.tiles = [
                this.origin,
                [this.origin[0]+1, this.origin[1]],
                [this.origin[0]+1, this.origin[1]+1],
                [this.origin[0]+1, this.origin[1]+2]
            ]
        }
    };

    canMove(board, direction) {
        let retVal = 1;
        this.tiles.forEach((tile) => {
            if (board.get(tile[0] + direction, tile[1]) != 0)
            {
                retVal = 0;
            }
        })
        return retVal;
    }

    move(board, direction) {
        if (this.canMove(board, direction) == 1)
        {
            this.tiles.forEach((tile) => {
                tile[0] += direction;
            })
            return 0;
        }
        else
        {
            return 1;
        }
    }

    canFall(board) {
        let retVal = 1;
        this.tiles.forEach((tile) => {
            if (board.get(tile[0], tile[1] + 1) != 0)
            {
                retVal = 0;
            }
        })
        return retVal;
    }

    fall(board) {
        // Check if we can fall
        if (this.canFall(board) == 1)
        {
            this.tiles.forEach((tile) => {
                tile[1] += 1;
            })
            return 0;
        }
        else
        {
            return 1;
        }
    }
    
    land(board) {
        this.tiles.forEach((occupiedSquare) => {
            board.board_rows[occupiedSquare[1]][occupiedSquare[0]] = this.color;
        })
    }
}

class Board {
    constructor(xSize, ySize) {
        this.xSize = xSize;
        this.ySize = ySize;
        this.board_rows = [];
        for (let i = 0; i < ySize; i++)
        {
            let board_row = [];
            for (let j = 0; j < xSize; j++)
            {
                board_row.push(0);
            }
            this.board_rows.push(board_row);
        }
    }
    
    set(x, y, color) {
        this.board_rows[y][x] = color;
    }

    get(x, y) {
        if (x >= 0 && x < this.xSize && y >= 0 && y < this.ySize)
        {
            return this.board_rows[y][x];
        }
        return -1; // Out of bounds
    }
}

function colorSquare(x, y, color)
{
    var c = document.getElementById("gameWindow");
    var ctx = c.getContext("2d");
    ctx.fillStyle = color_to_string(color);
    ctx.fillRect(BOARD_OFFSET_X + x*CELL_SIZE + 1, BOARD_OFFSET_Y + y*CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
}

function drawGameboard(board) {
    var c = document.getElementById("gameWindow");
    var ctx = c.getContext("2d");
    ctx.clearRect(BOARD_OFFSET_X, BOARD_OFFSET_Y, BOARD_WIDTH, BOARD_HEIGHT);
    ctx.beginPath();
    ctx.rect(BOARD_OFFSET_X, BOARD_OFFSET_Y, BOARD_WIDTH, BOARD_HEIGHT);
    //filling cells
    for (let x = 0; x < board.xSize; x++)
    {
        for (let y = 0; y < board.ySize; y++)
        {
            colorSquare(x, y, board.get(x, y));
        }
    }
    ctx.stroke();
}

function drawPiece(piece) {
    var c = document.getElementById("gameWindow");
    var ctx = c.getContext("2d");
    piece.tiles.forEach((tile) => {
        colorSquare(...tile, piece.color)
    });
}

function makePiece() {
    let piece = new Piece(randint(1,8));
    return piece;
}

let board = new Board(NUM_CELLS_X, NUM_CELLS_Y);
let ticksToFall = 3;
let fallTimer = ticksToFall;
let left_press = 0;
let right_press = 0;
piece = makePiece();

function gameLoop() {
    if (left_press) {
        left_press = 0;
        piece.move(board, -1);
    }
    if (right_press) {
        right_press = 0;
        piece.move(board, 1);
    }
    fallTimer--;
    if (fallTimer == 0) {
        if (piece.fall(board) == 1)
        {
            piece.land(board);
            piece = makePiece();
        }
        fallTimer = ticksToFall;
    }
    drawGameboard(board);
    drawPiece(piece);
}

setInterval(gameLoop, FRAME_DELTA);

document.addEventListener("keydown", function(event) {
    if (event.keyCode == 37) {
        left_press = 1;
    }
    else if (event.keyCode == 39) {
        right_press = 1;
    }
})
</script>