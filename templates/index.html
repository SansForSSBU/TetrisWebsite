<canvas id="gameWindow" width="600" height="900"></canvas>
<script>
const BOARD_OFFSET_X = 100;
const BOARD_OFFSET_Y = 100;
const FRAME_DELTA = 100; //ms
const CELL_SIZE = 40;
const NUM_CELLS_X = 10;
const NUM_CELLS_Y = 20;
const BOARD_WIDTH = CELL_SIZE*NUM_CELLS_X;
const BOARD_HEIGHT = CELL_SIZE*NUM_CELLS_Y;

const COLOR_ENUM = {
    BLACK: 0,
    CYAN: 1,
    YELLOW: 2,
    PURPLE: 3,
    GREEN: 4,
    BLUE: 5,
    RED: 6,
    ORANGE: 7
};

function color_to_string(enum_value)
{
    switch (enum_value) {
        case COLOR_ENUM.BLACK:
            return "black";
        case COLOR_ENUM.CYAN:
            return "cyan";
        case COLOR_ENUM.YELLOW:
            return "yellow";
        case COLOR_ENUM.PURPLE:
            return "purple";
        case COLOR_ENUM.GREEN:
            return "green";
        case COLOR_ENUM.BLUE:
            return "blue";
        case COLOR_ENUM.RED:
            return "red";
        case COLOR_ENUM.ORANGE:
            return "orange";
        default:
            throw new Error("Encountered an invalid color");
    }
}

class Piece {
    constructor(pieceType, pieceCoords) {
        this.color = pieceType;
        this.origin = pieceCoords;
        if (pieceType == 2) { // O piece
            this.tiles = [
                this.origin,
                [this.origin[0]+1, this.origin[1]],
                [this.origin[0], this.origin[1]+1],
                [this.origin[0]+1, this.origin[1]+1]
            ];
        }
    };

    canFall(board) {
        let retVal = 1;
        this.tiles.forEach((tile) => {
            if ((tile[1] + 1 >= board.ySize) || board.get(tile[0], tile[1] + 1) != 0)
            {
                retVal = 0;
            }
        })
        return retVal;
    }

    fall(board) {
        // Check if we can fall
        if (this.canFall(board) == 1)
        {
            this.tiles.forEach((occupiedSquare) => {
                occupiedSquare[1] += 1;
            })
            return 0;
        }
        else
        {
            return 1;
        }
    }
    
    land(board) {
        this.tiles.forEach((occupiedSquare) => {
            board.board_rows[occupiedSquare[1]][occupiedSquare[0]] = this.color;
        })
    }
}

class Board {
    constructor(xSize, ySize) {
        this.xSize = xSize;
        this.ySize = ySize;
        this.board_rows = [];
        for (let i = 0; i < ySize; i++)
        {
            let board_row = [];
            for (let j = 0; j < xSize; j++)
            {
                board_row.push(0);
            }
            this.board_rows.push(board_row);
        }
    }
    
    set(x, y, color) {
        this.board_rows[y][x] = color;
    }

    get(x, y) {
        return this.board_rows[y][x];
    }
}

function colorSquare(x, y, color)
{
    var c = document.getElementById("gameWindow");
    var ctx = c.getContext("2d");
    ctx.fillStyle = color_to_string(color);
    ctx.fillRect(BOARD_OFFSET_X + x*CELL_SIZE + 1, BOARD_OFFSET_Y + y*CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
}

function drawGameboard(board) {
    var c = document.getElementById("gameWindow");
    var ctx = c.getContext("2d");
    ctx.clearRect(BOARD_OFFSET_X, BOARD_OFFSET_Y, BOARD_WIDTH, BOARD_HEIGHT);
    ctx.beginPath();
    ctx.rect(BOARD_OFFSET_X, BOARD_OFFSET_Y, BOARD_WIDTH, BOARD_HEIGHT);
    //filling cells
    for (let x = 0; x < board.xSize; x++)
    {
        for (let y = 0; y < board.ySize; y++)
        {
            colorSquare(x, y, board.get(x, y));
        }
    }
    ctx.stroke();
}

function drawPiece(piece) {
    var c = document.getElementById("gameWindow");
    var ctx = c.getContext("2d");
    piece.tiles.forEach((tile) => {
        colorSquare(...tile, piece.color)
    });
}

function makePiece() {
    let piece = new Piece(2, [4, 0]);
    return piece;
}

let board = new Board(NUM_CELLS_X, NUM_CELLS_Y);
let ticksToFall = 3;
let fallTimer = ticksToFall;
piece = makePiece();

function gameLoop() {
    fallTimer--;
    if (fallTimer == 0) {
        if (piece.fall(board) == 1)
        {
            piece.land(board);
            piece = makePiece();
        }
        fallTimer = ticksToFall;
    }
    drawGameboard(board);
    drawPiece(piece);
}

setInterval(gameLoop, FRAME_DELTA);

</script>